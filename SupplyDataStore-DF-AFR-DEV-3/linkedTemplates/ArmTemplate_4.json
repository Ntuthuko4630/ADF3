{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "SupplyDataStore-DF-AFR-DEV-3"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/dsPhysyChemPROS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PhysChem",
					"type": "LinkedServiceReference",
					"parameters": {
						"ServerName": "10.111.240.178"
					}
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Replacement for FactsETL-df1",
				"folder": {
					"name": "Fact DF"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SDLeversOut2",
								"type": "DatasetReference"
							},
							"name": "SDLeversOut2"
						},
						{
							"dataset": {
								"referenceName": "vwDateAdjustLookup",
								"type": "DatasetReference"
							},
							"name": "vwDateAdjustLookup2"
						}
					],
					"sinks": [
						{
							"name": "snkDateAdjust2"
						},
						{
							"dataset": {
								"referenceName": "ODSStaging2",
								"type": "DatasetReference"
							},
							"name": "StagingSink2"
						}
					],
					"transformations": [
						{
							"name": "DerivedColumn1"
						},
						{
							"name": "SurrogateKey1"
						}
					],
					"script": "source(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tLastUpdated_Source as timestamp,\n\t\tTimeLine as string,\n\t\tSection as string,\n\t\tFlowMeasure as string,\n\t\tArea as string,\n\t\tUOM as string,\n\t\tValue as double,\n\t\tLastUpdated as timestamp,\n\t\tSourceLine as long,\n\t\tPeriodDate as date\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: (\"SELECT BrewName,DateStarting,LastUpdated_Source,TimeLine,Section,FlowMeasure,Area,UOM,Value,LastUpdated,SourceLine,PeriodDate FROM ODS.vwSD_Levers_ETL0\"),\n\tformat: 'query') ~> SDLeversOut2\nsource(output(\n\t\tSiteName as string,\n\t\tDateAdjust as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> vwDateAdjustLookup2\nSDLeversOut2 derive(DateAdjust = snkDateAdjust2#lookup(BrewName).DateAdjust,\n\t\tLastUpdated1 = currentTimestamp(),\n\t\tTimeLine_tr = trim(TimeLine),\n\t\tfkBatch = toInteger(0)) ~> DerivedColumn1\nDerivedColumn1 keyGenerate(output(pkiSDLevers as long),\n\tstartAt: 1L) ~> SurrogateKey1\nvwDateAdjustLookup2 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tkeys:['SiteName'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tSiteName,\n\t\tDateAdjust\n\t)) ~> snkDateAdjust2\nSurrogateKey1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiSDLevers as long,\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tLastUpdated_Source as timestamp,\n\t\tTimeLine as string,\n\t\tSection as string,\n\t\tFlowMeasure as string,\n\t\tArea as string,\n\t\tUOM as string,\n\t\tValue as double,\n\t\tfkBatchID as integer,\n\t\tLastUpdated as timestamp,\n\t\tLastUpdatedBy as string,\n\t\tSourceLine as long,\n\t\tPeriodDate as date,\n\t\tPeriodAdjust as integer\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\ttruncate:true,\n\tformat: 'table',\n\tdateFormat:'yyyy/MM/dd',\n\ttimestampFormat:'yyyy/MM/dd hh:mm:ss',\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiSDLevers,\n\t\tBrewName,\n\t\tDateStarting,\n\t\tLastUpdated_Source,\n\t\tTimeLine,\n\t\tSection,\n\t\tFlowMeasure,\n\t\tArea,\n\t\tUOM,\n\t\tValue,\n\t\tfkBatchID = fkBatch,\n\t\tLastUpdated = LastUpdated1,\n\t\tSourceLine,\n\t\tPeriodDate,\n\t\tPeriodAdjust = DateAdjust\n\t)) ~> StagingSink2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_SDLevers",
								"type": "DatasetReference"
							},
							"name": "StagingTable"
						},
						{
							"dataset": {
								"referenceName": "SourceIDLookup",
								"type": "DatasetReference"
							},
							"name": "SourceIDs"
						},
						{
							"dataset": {
								"referenceName": "REF_FactLookup",
								"type": "DatasetReference"
							},
							"name": "FactLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_MetricLookup",
								"type": "DatasetReference"
							},
							"name": "MetricLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SIteLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_LocationLookup",
								"type": "DatasetReference"
							},
							"name": "LocationLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_TimeLineLookup",
								"type": "DatasetReference"
							},
							"name": "TimeLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_PackLineLookup",
								"type": "DatasetReference"
							},
							"name": "PackLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_BrewhouseLookup",
								"type": "DatasetReference"
							},
							"name": "BrewhouseLookup"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIRead",
								"type": "DatasetReference"
							},
							"name": "FactCopy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact2",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact1",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactD"
						},
						{
							"name": "SiteLookupCache"
						},
						{
							"name": "MetricLookupCache"
						},
						{
							"name": "LocationCache"
						},
						{
							"name": "TimeLineCache"
						},
						{
							"name": "PackLineCache"
						},
						{
							"name": "BrewhouseCache"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactWM"
						},
						{
							"dataset": {
								"referenceName": "FactUpdateTracker",
								"type": "DatasetReference"
							},
							"name": "UpdateTracker1"
						},
						{
							"dataset": {
								"referenceName": "FactUpdateTracker",
								"type": "DatasetReference"
							},
							"name": "UpdateTracker2"
						}
					],
					"transformations": [
						{
							"name": "UpdateRecords",
							"description": "Input rows that match on SourceLine"
						},
						{
							"name": "ExistingHash",
							"description": "Hash of characterising fields to match WTD and MTD elements"
						},
						{
							"name": "MarkUpdate1",
							"description": "Update the value and lastupdated date"
						},
						{
							"name": "InputHash",
							"description": "Hash of elements to identify similar records"
						},
						{
							"name": "NewRecords",
							"description": "Input rows that do not match on SourceLine\nNOTE Exists does not join the subquery"
						},
						{
							"name": "SplitTimeLines",
							"description": "Split MTD and WTD records from DAY records"
						},
						{
							"name": "MarkUpdate2",
							"description": "Update the value, sourceline and lastupdated date"
						},
						{
							"name": "Lookup1"
						},
						{
							"name": "Select1",
							"description": "pki and new value and lastupdated"
						},
						{
							"name": "Select2",
							"description": "PKI, and new sourceline, lastupdated and value"
						},
						{
							"name": "KeyFromSourceline",
							"description": "Look up the fact pki from the source line for matching source lines"
						},
						{
							"name": "LookupCurrent",
							"description": "Lookup primary key for matched record from sourceline"
						},
						{
							"name": "LookupKeys"
						},
						{
							"name": "LocLookup"
						},
						{
							"name": "PackLineKey"
						},
						{
							"name": "BrewhouseKey"
						},
						{
							"name": "MarkInsert"
						},
						{
							"name": "ConditionalSplit1"
						},
						{
							"name": "Select3"
						},
						{
							"name": "LookupKeys2"
						},
						{
							"name": "MarkInsert1"
						},
						{
							"name": "Select4"
						},
						{
							"name": "Select5"
						},
						{
							"name": "Select6"
						},
						{
							"name": "UpdateTracker1Metadata"
						},
						{
							"name": "UpdateTracker2Metadata"
						},
						{
							"name": "SelectLUSite"
						},
						{
							"name": "SelectLUMetric"
						},
						{
							"name": "SelectLULocation"
						},
						{
							"name": "SelectLUTimeLine"
						},
						{
							"name": "SelectLUPackLine"
						},
						{
							"name": "SelectLUBrewhouse"
						}
					],
					"script": "parameters{\n\tBatchNumber as long (toLong(0))\n}\nsource(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingTable\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SourceIDs\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tMetricName as string,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactLookup\nsource(output(\n\t\tpkiMetric as long,\n\t\tMetricLU as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MetricLookup\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SIteLookup\nsource(output(\n\t\tpkiLocation as long,\n\t\tDivision as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LocationLookup\nsource(output(\n\t\tpkiTimeLine as integer,\n\t\tTimeLine as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TimeLineLookup\nsource(output(\n\t\tpkiPackLine as long,\n\t\tfkSite as long,\n\t\tLineName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PackLineLookup\nsource(output(\n\t\tpkiBrewhouse as long,\n\t\tfkSite as long,\n\t\tBrewhouseName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> BrewhouseLookup\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactCopy\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:false,\n\tbroadcast: 'auto')~> UpdateRecords\nFactLookup derive(hashExisting = md5(toString(fkDate), BrewName, TimeLine, Line, Brewhouse, MetricName)) ~> ExistingHash\nSelect6 alterRow(updateIf(true())) ~> MarkUpdate1\nStagingTable derive(TMTimeLine = (trim(TimeLine) == 'MTD') || (trim(TimeLine) == 'YTD'),\n\t\tInputHash = md5(toString(PeriodDate), BrewName, TimeLine, Line, Brewhouse, MetricName),\n\t\tLocLookup1 = lower(trim(Area) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, ''))),\n\t\tLineLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Line,\n\t\tBrewhouseLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Brewhouse,\n\t\tfkDate = PeriodDate) ~> InputHash\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewRecords\nNewRecords split(or(trim(TimeLine) == \"MTD\",  trim(TimeLine) == \"WTD\"),\n\tdisjoint: false) ~> SplitTimeLines@(MTDWTDTimeLines, DAYTimeLine)\nConditionalSplit1@FuzzyMatched alterRow(updateIf(true())) ~> MarkUpdate2\nSplitTimeLines@MTDWTDTimeLines, ExistingHash lookup(InputHash == hashExisting,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nMarkUpdate1 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nMarkUpdate2 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nFactLookup select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate,\n\t\tBrewName,\n\t\tTimeLine,\n\t\tSubdivision,\n\t\tLine,\n\t\tBrewhouse,\n\t\tLocationLookup,\n\t\tMetricName,\n\t\tSourceLine,\n\t\tLastUpdated\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> KeyFromSourceline\nUpdateRecords, FactCopy lookup(StagingTable@SourceLine == FactCopy@SourceLine,\n\tmultiple: true,\n\tbroadcast: 'auto',\n\tpickup: 'any')~> LookupCurrent\nSplitTimeLines@DAYTimeLine derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong($BatchNumber),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys\nLocationLookup derive(LocLookup = lower(trim(Subdivision) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, '')))) ~> LocLookup\nPackLineLookup derive(LineKey = toString(fkSite) + '|' + LineName) ~> PackLineKey\nBrewhouseLookup derive(BrewhouseKey = toString(fkSite) + '|' + BrewhouseName) ~> BrewhouseKey\nLookupKeys alterRow(insertIf(true())) ~> MarkInsert\nSelect3 split(InputHash == hashExisting,\n\tdisjoint: false) ~> ConditionalSplit1@(FuzzyMatched, FuzzyUnmatched)\nLookup1 select(mapColumn(\n\t\tBrewName = SplitTimeLines@MTDWTDTimeLines@BrewName,\n\t\tDateStarting,\n\t\tTimeLine = SplitTimeLines@MTDWTDTimeLines@TimeLine,\n\t\tFlowMeasure,\n\t\tSection,\n\t\tArea,\n\t\tValue,\n\t\tLine = SplitTimeLines@MTDWTDTimeLines@Line,\n\t\tBrewhouse = SplitTimeLines@MTDWTDTimeLines@Brewhouse,\n\t\tMetricName = SplitTimeLines@MTDWTDTimeLines@MetricName,\n\t\tPeriodDate,\n\t\tLastUpdated = SplitTimeLines@MTDWTDTimeLines@LastUpdated,\n\t\tfkBatchID,\n\t\tSourceLine = SplitTimeLines@MTDWTDTimeLines@SourceLine,\n\t\tInputHash,\n\t\tpkiFactKPI,\n\t\tfkDate = SplitTimeLines@MTDWTDTimeLines@fkDate,\n\t\thashExisting,\n\t\tLocLookup1,\n\t\tLineLookup,\n\t\tBrewhouseLookup\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select3\nConditionalSplit1@FuzzyUnmatched derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong($BatchNumber),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys2\nLookupKeys2 alterRow(insertIf(true())) ~> MarkInsert1\nMarkInsert1 select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select4\nMarkInsert select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select5\nLookupCurrent select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate = FactCopy@fkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue = StagingTable@Value,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine = FactCopy@SourceLine,\n\t\tfkBatch = fkBatchID,\n\t\tLastUpdated = StagingTable@LastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select6\nSelect1 derive(SourceLine = toLong(null()),\n\t\tDataSource = \"Day branch\",\n\t\tUpdated = fromUTC(currentUTC(), \"South Africa Standard Time\")) ~> UpdateTracker1Metadata\nSelect2 derive(DataSource = \"Week/Month branch\",\n\t\tUpdated = fromUTC(currentUTC(), \"South Africa Standard Time\")) ~> UpdateTracker2Metadata\nSIteLookup select(mapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: true) ~> SelectLUSite\nMetricLookup select(mapColumn(\n\t\tfkMetric = pkiMetric,\n\t\tMetricLU\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectLUMetric\nLocLookup select(mapColumn(\n\t\tfkLocation = pkiLocation,\n\t\tLocationLookup\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectLULocation\nTimeLineLookup select(mapColumn(\n\t\tfkTimeLine = pkiTimeLine,\n\t\tTimeLineLU = TimeLine\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectLUTimeLine\nPackLineKey select(mapColumn(\n\t\tfkPackLine = pkiPackLine,\n\t\tLineKey\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectLUPackLine\nBrewhouseKey select(mapColumn(\n\t\tfkBrewhouse = pkiBrewhouse,\n\t\tBrewhouseKey\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectLUBrewhouse\nSelect1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 7,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t)) ~> UpdateFact2\nSelect2 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 6,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tValue,\n\t\tSourceLine,\n\t\tLastUpdated\n\t)) ~> UpdateFact1\nSelect5 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 4,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactD\nSelectLUSite sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> SiteLookupCache\nSelectLUMetric sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tkeys:['MetricLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkMetric,\n\t\tMetricLU\n\t)) ~> MetricLookupCache\nSelectLULocation sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LocationLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkLocation,\n\t\tLocationLookup\n\t)) ~> LocationCache\nSelectLUTimeLine sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['TimeLineLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkTimeLine,\n\t\tTimeLineLU\n\t)) ~> TimeLineCache\nSelectLUPackLine sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tkeys:['LineKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkPackLine,\n\t\tLineKey\n\t)) ~> PackLineCache\nSelectLUBrewhouse sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tkeys:['BrewhouseKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkBrewhouse,\n\t\tBrewhouseKey\n\t)) ~> BrewhouseCache\nSelect4 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 5,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactWM\nUpdateTracker1Metadata sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tLastUpdated as timestamp,\n\t\tValue as double,\n\t\tSourceLine as long,\n\t\tDataSource as string,\n\t\tUpdated as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 8,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue,\n\t\tSourceLine,\n\t\tDataSource,\n\t\tUpdated\n\t)) ~> UpdateTracker1\nUpdateTracker2Metadata sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tLastUpdated as timestamp,\n\t\tValue as double,\n\t\tSourceLine as long,\n\t\tDataSource as string,\n\t\tUpdated as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tsaveOrder: 9,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue,\n\t\tSourceLine,\n\t\tDataSource,\n\t\tUpdated\n\t)) ~> UpdateTracker2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL2_TEST')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_SDLevers",
								"type": "DatasetReference"
							},
							"name": "StagingTable"
						},
						{
							"dataset": {
								"referenceName": "SourceIDLookup",
								"type": "DatasetReference"
							},
							"name": "SourceIDs"
						},
						{
							"dataset": {
								"referenceName": "REF_FactLookup",
								"type": "DatasetReference"
							},
							"name": "FactLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_MetricLookup",
								"type": "DatasetReference"
							},
							"name": "MetricLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SIteLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_LocationLookup",
								"type": "DatasetReference"
							},
							"name": "LocationLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_TimeLineLookup",
								"type": "DatasetReference"
							},
							"name": "TimeLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_PackLineLookup",
								"type": "DatasetReference"
							},
							"name": "PackLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_BrewhouseLookup",
								"type": "DatasetReference"
							},
							"name": "BrewhouseLookup"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIRead",
								"type": "DatasetReference"
							},
							"name": "FactCopy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact2",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact1",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactD"
						},
						{
							"name": "SiteLookupCache"
						},
						{
							"name": "MetricLookupCache"
						},
						{
							"name": "LocationCache"
						},
						{
							"name": "TimeLineCache"
						},
						{
							"name": "PackLineCache"
						},
						{
							"name": "BrewhouseCache"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactWM"
						},
						{
							"dataset": {
								"referenceName": "FactUpdateTracker",
								"type": "DatasetReference"
							},
							"name": "UpdateTracker1"
						},
						{
							"dataset": {
								"referenceName": "FactUpdateTracker",
								"type": "DatasetReference"
							},
							"name": "UpdateTracker2"
						}
					],
					"transformations": [
						{
							"name": "UpdateRecords",
							"description": "Input rows that match on SourceLine"
						},
						{
							"name": "ExistingHash",
							"description": "Hash of characterising fields to match WTD and MTD elements"
						},
						{
							"name": "MarkUpdate1",
							"description": "Update the value and lastupdated date"
						},
						{
							"name": "InputHash",
							"description": "Hash of elements to identify similar records"
						},
						{
							"name": "NewRecords",
							"description": "Input rows that do not match on SourceLine\nNOTE Exists does not join the subquery"
						},
						{
							"name": "SplitTimeLines",
							"description": "Split MTD and WTD records from DAY records"
						},
						{
							"name": "MarkUpdate2",
							"description": "Update the value, sourceline and lastupdated date"
						},
						{
							"name": "Lookup1"
						},
						{
							"name": "Select1",
							"description": "pki and new value and lastupdated"
						},
						{
							"name": "Select2",
							"description": "PKI, and new sourceline, lastupdated and value"
						},
						{
							"name": "KeyFromSourceline",
							"description": "Look up the fact pki from the source line for matching source lines"
						},
						{
							"name": "LookupCurrent",
							"description": "Lookup primary key for matched record from sourceline"
						},
						{
							"name": "LookupKeys"
						},
						{
							"name": "LocLookup"
						},
						{
							"name": "PackLineKey"
						},
						{
							"name": "BrewhouseKey"
						},
						{
							"name": "MarkInsert"
						},
						{
							"name": "ConditionalSplit1"
						},
						{
							"name": "Select3"
						},
						{
							"name": "LookupKeys2"
						},
						{
							"name": "MarkInsert1"
						},
						{
							"name": "Select4"
						},
						{
							"name": "Select5"
						},
						{
							"name": "Select6"
						},
						{
							"name": "UpdateTracker1Metadata"
						},
						{
							"name": "UpdateTracker2Metadata"
						}
					],
					"script": "parameters{\n\tBatchNumber as long (toLong(0))\n}\nsource(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingTable\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SourceIDs\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tMetricName as string,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactLookup\nsource(output(\n\t\tpkiMetric as long,\n\t\tMetricLU as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MetricLookup\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SIteLookup\nsource(output(\n\t\tpkiLocation as long,\n\t\tDivision as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LocationLookup\nsource(output(\n\t\tpkiTimeLine as integer,\n\t\tTimeLine as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TimeLineLookup\nsource(output(\n\t\tpkiPackLine as long,\n\t\tfkSite as long,\n\t\tLineName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PackLineLookup\nsource(output(\n\t\tpkiBrewhouse as long,\n\t\tfkSite as long,\n\t\tBrewhouseName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> BrewhouseLookup\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactCopy\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:false,\n\tbroadcast: 'auto')~> UpdateRecords\nFactLookup derive(hashExisting = md5(toString(fkDate), BrewName, TimeLine, Line, Brewhouse, MetricName)) ~> ExistingHash\nSelect6 alterRow(updateIf(true())) ~> MarkUpdate1\nStagingTable derive(TMTimeLine = (trim(TimeLine) == 'MTD') || (trim(TimeLine) == 'YTD'),\n\t\tInputHash = md5(toString(PeriodDate), BrewName, TimeLine, Line, Brewhouse, MetricName),\n\t\tLocLookup1 = lower(trim(Area) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, ''))),\n\t\tLineLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Line,\n\t\tBrewhouseLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Brewhouse,\n\t\tfkDate = PeriodDate) ~> InputHash\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewRecords\nNewRecords split(or(trim(TimeLine) == \"MTD\",  trim(TimeLine) == \"WTD\"),\n\tdisjoint: false) ~> SplitTimeLines@(MTDWTDTimeLines, DAYTimeLine)\nConditionalSplit1@FuzzyMatched alterRow(updateIf(true())) ~> MarkUpdate2\nSplitTimeLines@MTDWTDTimeLines, ExistingHash lookup(InputHash == hashExisting,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nMarkUpdate1 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nMarkUpdate2 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nFactLookup select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate,\n\t\tBrewName,\n\t\tTimeLine,\n\t\tSubdivision,\n\t\tLine,\n\t\tBrewhouse,\n\t\tLocationLookup,\n\t\tMetricName,\n\t\tSourceLine,\n\t\tLastUpdated\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> KeyFromSourceline\nUpdateRecords, FactCopy lookup(StagingTable@SourceLine == FactCopy@SourceLine,\n\tmultiple: true,\n\tbroadcast: 'auto',\n\tpickup: 'any')~> LookupCurrent\nSplitTimeLines@DAYTimeLine derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong(327),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys\nLocationLookup derive(LocLookup = lower(trim(Subdivision) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, '')))) ~> LocLookup\nPackLineLookup derive(LineKey = toString(fkSite) + '|' + LineName) ~> PackLineKey\nBrewhouseLookup derive(BrewhouseKey = toString(fkSite) + '|' + BrewhouseName) ~> BrewhouseKey\nLookupKeys alterRow(insertIf(true())) ~> MarkInsert\nSelect3 split(InputHash == hashExisting,\n\tdisjoint: false) ~> ConditionalSplit1@(FuzzyMatched, FuzzyUnmatched)\nLookup1 select(mapColumn(\n\t\tBrewName = SplitTimeLines@MTDWTDTimeLines@BrewName,\n\t\tDateStarting,\n\t\tTimeLine = SplitTimeLines@MTDWTDTimeLines@TimeLine,\n\t\tFlowMeasure,\n\t\tSection,\n\t\tArea,\n\t\tValue,\n\t\tLine = SplitTimeLines@MTDWTDTimeLines@Line,\n\t\tBrewhouse = SplitTimeLines@MTDWTDTimeLines@Brewhouse,\n\t\tMetricName = SplitTimeLines@MTDWTDTimeLines@MetricName,\n\t\tPeriodDate,\n\t\tLastUpdated = SplitTimeLines@MTDWTDTimeLines@LastUpdated,\n\t\tfkBatchID,\n\t\tSourceLine = SplitTimeLines@MTDWTDTimeLines@SourceLine,\n\t\tInputHash,\n\t\tpkiFactKPI,\n\t\tfkDate = SplitTimeLines@MTDWTDTimeLines@fkDate,\n\t\thashExisting,\n\t\tLocLookup1,\n\t\tLineLookup,\n\t\tBrewhouseLookup\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select3\nConditionalSplit1@FuzzyUnmatched derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong(328),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys2\nLookupKeys2 alterRow(insertIf(true())) ~> MarkInsert1\nMarkInsert1 select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select4\nMarkInsert select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select5\nLookupCurrent select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate = FactCopy@fkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue = StagingTable@Value,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine = FactCopy@SourceLine,\n\t\tfkBatch = fkBatchID,\n\t\tLastUpdated = StagingTable@LastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select6\nSelect1 derive(SourceLine = toLong(null()),\n\t\tDataSource = \"Day branch\",\n\t\tUpdated = fromUTC(currentUTC(), \"South Africa Standard Time\")) ~> UpdateTracker1Metadata\nSelect2 derive(DataSource = \"Week/Month branch\",\n\t\tUpdated = fromUTC(currentUTC(), \"South Africa Standard Time\")) ~> UpdateTracker2Metadata\nSelect1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 7,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t)) ~> UpdateFact2\nSelect2 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 6,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tValue,\n\t\tSourceLine,\n\t\tLastUpdated\n\t)) ~> UpdateFact1\nSelect5 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 4,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactD\nSIteLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> SiteLookupCache\nMetricLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['MetricLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkMetric = pkiMetric,\n\t\tMetricLU\n\t)) ~> MetricLookupCache\nLocLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LocationLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkLocation = pkiLocation,\n\t\tLocationLookup\n\t)) ~> LocationCache\nTimeLineLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['TimeLine'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkTimeLine = pkiTimeLine,\n\t\tTimeLine\n\t)) ~> TimeLineCache\nPackLineKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LineKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkPackLine = pkiPackLine,\n\t\tLineKey\n\t)) ~> PackLineCache\nBrewhouseKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['BrewhouseKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 2,\n\tmapColumn(\n\t\tfkBrewhouse = pkiBrewhouse,\n\t\tBrewhouseKey\n\t)) ~> BrewhouseCache\nSelect4 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 5,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactWM\nUpdateTracker1Metadata sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tLastUpdated as timestamp,\n\t\tValue as double,\n\t\tSourceLine as long,\n\t\tDataSource as string,\n\t\tUpdated as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 8,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue,\n\t\tSourceLine,\n\t\tDataSource,\n\t\tUpdated\n\t)) ~> UpdateTracker1\nUpdateTracker2Metadata sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tLastUpdated as timestamp,\n\t\tValue as double,\n\t\tSourceLine as long,\n\t\tDataSource as string,\n\t\tUpdated as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tsaveOrder: 9,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue,\n\t\tSourceLine,\n\t\tDataSource,\n\t\tUpdated\n\t)) ~> UpdateTracker2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL2_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Fact DF"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_SDLevers",
								"type": "DatasetReference"
							},
							"name": "StagingTable"
						},
						{
							"dataset": {
								"referenceName": "SourceIDLookup",
								"type": "DatasetReference"
							},
							"name": "SourceIDs"
						},
						{
							"dataset": {
								"referenceName": "REF_FactLookup",
								"type": "DatasetReference"
							},
							"name": "FactLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_MetricLookup",
								"type": "DatasetReference"
							},
							"name": "MetricLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SIteLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_LocationLookup",
								"type": "DatasetReference"
							},
							"name": "LocationLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_TimeLineLookup",
								"type": "DatasetReference"
							},
							"name": "TimeLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_PackLineLookup",
								"type": "DatasetReference"
							},
							"name": "PackLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_BrewhouseLookup",
								"type": "DatasetReference"
							},
							"name": "BrewhouseLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "DWFactKPI1",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "DWFactKPI2",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DebugOutput",
								"type": "DatasetReference"
							},
							"name": "DriftedDebugSink"
						},
						{
							"name": "SiteLookupCache"
						},
						{
							"name": "MetricLookupCache"
						},
						{
							"name": "LocationCache"
						},
						{
							"name": "TimeLineCache"
						},
						{
							"name": "PackLineCache"
						},
						{
							"name": "BrewhouseCache"
						}
					],
					"transformations": [
						{
							"name": "UpdateRecords",
							"description": "Input rows that match on SourceLine"
						},
						{
							"name": "ExistingHash",
							"description": "Hash of characterising fields to match WTD and MTD elements"
						},
						{
							"name": "MarkUpdate1",
							"description": "Update the value and lastupdated date"
						},
						{
							"name": "InputHash",
							"description": "Hash of elements to identify similar records"
						},
						{
							"name": "NewRecords",
							"description": "Input rows that do not match on SourceLine"
						},
						{
							"name": "SplitTimeLines",
							"description": "Split MTD and WTD records from DAY records"
						},
						{
							"name": "MarkUpdate2",
							"description": "Update the value, sourceline and lastupdated date"
						},
						{
							"name": "Lookup1"
						},
						{
							"name": "RecentUpdates",
							"description": "Filter input fields updated more recently than the fact field"
						},
						{
							"name": "Select1",
							"description": "pki and new value and lastupdated"
						},
						{
							"name": "Select2",
							"description": "PKI, and new sourceline, lastupdated and value"
						},
						{
							"name": "KeyFromSourceline"
						},
						{
							"name": "LookupPrimaryKey",
							"description": "Lookup primary key for matched record from sourceline"
						},
						{
							"name": "LookupKeys"
						},
						{
							"name": "LocLookup"
						},
						{
							"name": "PackLineKey"
						},
						{
							"name": "BrewhouseKey"
						},
						{
							"name": "MarkInsert"
						}
					],
					"script": "parameters{\n\tbatchID as integer (0)\n}\nsource(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingTable\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SourceIDs\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tMetricName as string,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactLookup\nsource(output(\n\t\tpkiMetric as long,\n\t\tMetricLU as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MetricLookup\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SIteLookup\nsource(output(\n\t\tpkiLocation as long,\n\t\tDivision as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LocationLookup\nsource(output(\n\t\tpkiTimeLine as integer,\n\t\tTimeLine as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TimeLineLookup\nsource(output(\n\t\tpkiPackLine as long,\n\t\tfkSite as long,\n\t\tLineName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PackLineLookup\nsource(output(\n\t\tpkiBrewhouse as long,\n\t\tfkSite as long,\n\t\tBrewhouseName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> BrewhouseLookup\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:false,\n\tbroadcast: 'auto')~> UpdateRecords\nFactLookup derive(hashExisting = md5(toString(fkDate), BrewName, TimeLine, Line, Brewhouse, MetricName)) ~> ExistingHash\nLookupPrimaryKey alterRow(updateIf(true())) ~> MarkUpdate1\nStagingTable derive(InputHash = md5(toString(PeriodDate), BrewName, TimeLine, Line, Brewhouse, MetricName),\n\t\tBatchID = $batchID,\n\t\tLocLookup1 = lower(trim(Area) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, ''))),\n\t\tLineLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Line,\n\t\tBrewhouseLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Brewhouse) ~> InputHash\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewRecords\nNewRecords split(TimeLine == 'MTD' || TimeLine == 'YTD',\n\tdisjoint: false) ~> SplitTimeLines@(MTDWTDTimeLines, DAYTimeLine)\nRecentUpdates alterRow(updateIf(true())) ~> MarkUpdate2\nSplitTimeLines@MTDWTDTimeLines, ExistingHash lookup(InputHash == hashExisting,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nLookup1 filter(SplitTimeLines@MTDWTDTimeLines@LastUpdated > FactLookup@LastUpdated) ~> RecentUpdates\nMarkUpdate1 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkBatchID = BatchID,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nMarkUpdate2 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine = SplitTimeLines@MTDWTDTimeLines@SourceLine,\n\t\tLastUpdated = SplitTimeLines@MTDWTDTimeLines@LastUpdated,\n\t\tfkBatchID = BatchID,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nFactLookup select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> KeyFromSourceline\nUpdateRecords, KeyFromSourceline lookup(StagingTable@SourceLine == KeyFromSourceline@SourceLine,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupPrimaryKey\nSplitTimeLines@DAYTimeLine derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1) ~> LookupKeys\nLocationLookup derive(LocLookup = lower(trim(Subdivision) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, '')))) ~> LocLookup\nPackLineLookup derive(LineKey = toString(fkSite) + '|' + LineName) ~> PackLineKey\nBrewhouseLookup derive(BrewhouseKey = toString(fkSite) + '|' + BrewhouseName) ~> BrewhouseKey\nLookupKeys alterRow(insertIf(true())) ~> MarkInsert\nSelect1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tValue,\n\t\tLastUpdated,\n\t\tpkiFactKPI\n\t)) ~> DWFactKPI1\nSelect2 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tValue,\n\t\tSourceLine,\n\t\tLastUpdated\n\t)) ~> DWFactKPI2\nMarkInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tPlant as string,\n\t\t{Fin Year} as string,\n\t\tMonth as string,\n\t\t{MTD/YTD} as string,\n\t\t{KPI Name} as string,\n\t\tTarget as string\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\trecreate:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> DriftedDebugSink\nSIteLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> SiteLookupCache\nMetricLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['MetricLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tfkMetric = pkiMetric,\n\t\tMetricLU\n\t)) ~> MetricLookupCache\nLocLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LocationLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tfkLocation = pkiLocation,\n\t\tLocationLookup\n\t)) ~> LocationCache\nTimeLineLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['TimeLine'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tfkTimeLine = pkiTimeLine,\n\t\tTimeLine\n\t)) ~> TimeLineCache\nPackLineKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LineKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkPackLine = pkiPackLine,\n\t\tLineKey\n\t)) ~> PackLineCache\nBrewhouseKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['BrewhouseKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkBrewhouse = pkiBrewhouse,\n\t\tBrewhouseKey\n\t)) ~> BrewhouseCache"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL2_copy2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Fact DF"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_SDLevers",
								"type": "DatasetReference"
							},
							"name": "StagingTable"
						},
						{
							"dataset": {
								"referenceName": "SourceIDLookup",
								"type": "DatasetReference"
							},
							"name": "SourceIDs"
						},
						{
							"dataset": {
								"referenceName": "REF_FactLookup",
								"type": "DatasetReference"
							},
							"name": "FactLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_MetricLookup",
								"type": "DatasetReference"
							},
							"name": "MetricLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SIteLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_LocationLookup",
								"type": "DatasetReference"
							},
							"name": "LocationLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_TimeLineLookup",
								"type": "DatasetReference"
							},
							"name": "TimeLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_PackLineLookup",
								"type": "DatasetReference"
							},
							"name": "PackLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_BrewhouseLookup",
								"type": "DatasetReference"
							},
							"name": "BrewhouseLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "DWFactKPI1",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "DWFactKPI2",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DebugOutput",
								"type": "DatasetReference"
							},
							"name": "DriftedDebugSink"
						},
						{
							"name": "SiteLookupCache"
						},
						{
							"name": "MetricLookupCache"
						},
						{
							"name": "LocationCache"
						},
						{
							"name": "TimeLineCache"
						},
						{
							"name": "PackLineCache"
						},
						{
							"name": "BrewhouseCache"
						}
					],
					"transformations": [
						{
							"name": "UpdateRecords",
							"description": "Input rows that match on SourceLine"
						},
						{
							"name": "ExistingHash",
							"description": "Hash of characterising fields to match WTD and MTD elements"
						},
						{
							"name": "MarkUpdate1",
							"description": "Update the value and lastupdated date"
						},
						{
							"name": "InputHash",
							"description": "Hash of elements to identify similar records"
						},
						{
							"name": "NewRecords",
							"description": "Input rows that do not match on SourceLine"
						},
						{
							"name": "SplitTimeLines",
							"description": "Split MTD and WTD records from DAY records"
						},
						{
							"name": "MarkUpdate2",
							"description": "Update the value, sourceline and lastupdated date"
						},
						{
							"name": "Lookup1"
						},
						{
							"name": "RecentUpdates",
							"description": "Filter input fields updated more recently than the fact field"
						},
						{
							"name": "Select1",
							"description": "pki and new value and lastupdated"
						},
						{
							"name": "Select2",
							"description": "PKI, and new sourceline, lastupdated and value"
						},
						{
							"name": "KeyFromSourceline"
						},
						{
							"name": "LookupPrimaryKey",
							"description": "Lookup primary key for matched record from sourceline"
						},
						{
							"name": "LookupKeys"
						},
						{
							"name": "LocLookup"
						},
						{
							"name": "PackLineKey"
						},
						{
							"name": "BrewhouseKey"
						},
						{
							"name": "MarkInsert"
						}
					],
					"script": "parameters{\n\tbatchID as integer (0)\n}\nsource(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingTable\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SourceIDs\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tMetricName as string,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactLookup\nsource(output(\n\t\tpkiMetric as long,\n\t\tMetricLU as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MetricLookup\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SIteLookup\nsource(output(\n\t\tpkiLocation as long,\n\t\tDivision as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LocationLookup\nsource(output(\n\t\tpkiTimeLine as integer,\n\t\tTimeLine as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TimeLineLookup\nsource(output(\n\t\tpkiPackLine as long,\n\t\tfkSite as long,\n\t\tLineName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PackLineLookup\nsource(output(\n\t\tpkiBrewhouse as long,\n\t\tfkSite as long,\n\t\tBrewhouseName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> BrewhouseLookup\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:false,\n\tbroadcast: 'auto')~> UpdateRecords\nFactLookup derive(hashExisting = md5(toString(fkDate), BrewName, TimeLine, Line, Brewhouse, MetricName)) ~> ExistingHash\nLookupPrimaryKey alterRow(updateIf(true())) ~> MarkUpdate1\nStagingTable derive(InputHash = md5(toString(PeriodDate), BrewName, TimeLine, Line, Brewhouse, MetricName),\n\t\tBatchID = $batchID,\n\t\tLocLookup1 = lower(trim(Area) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, ''))),\n\t\tLineLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Line,\n\t\tBrewhouseLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Brewhouse) ~> InputHash\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewRecords\nNewRecords split(TimeLine == 'MTD' || TimeLine == 'YTD',\n\tdisjoint: false) ~> SplitTimeLines@(MTDWTDTimeLines, DAYTimeLine)\nRecentUpdates alterRow(updateIf(true())) ~> MarkUpdate2\nSplitTimeLines@MTDWTDTimeLines, ExistingHash lookup(InputHash == hashExisting,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nLookup1 filter(SplitTimeLines@MTDWTDTimeLines@LastUpdated > FactLookup@LastUpdated) ~> RecentUpdates\nMarkUpdate1 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkBatchID = BatchID,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nMarkUpdate2 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine = SplitTimeLines@MTDWTDTimeLines@SourceLine,\n\t\tLastUpdated = SplitTimeLines@MTDWTDTimeLines@LastUpdated,\n\t\tfkBatchID = BatchID,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nFactLookup select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> KeyFromSourceline\nUpdateRecords, KeyFromSourceline lookup(StagingTable@SourceLine == KeyFromSourceline@SourceLine,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupPrimaryKey\nSplitTimeLines@DAYTimeLine derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1) ~> LookupKeys\nLocationLookup derive(LocLookup = lower(trim(Subdivision) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, '')))) ~> LocLookup\nPackLineLookup derive(LineKey = toString(fkSite) + '|' + LineName) ~> PackLineKey\nBrewhouseLookup derive(BrewhouseKey = toString(fkSite) + '|' + BrewhouseName) ~> BrewhouseKey\nLookupKeys alterRow(insertIf(true())) ~> MarkInsert\nSelect1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tValue,\n\t\tLastUpdated,\n\t\tpkiFactKPI\n\t)) ~> DWFactKPI1\nSelect2 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tValue,\n\t\tSourceLine,\n\t\tLastUpdated\n\t)) ~> DWFactKPI2\nMarkInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tPlant as string,\n\t\t{Fin Year} as string,\n\t\tMonth as string,\n\t\t{MTD/YTD} as string,\n\t\t{KPI Name} as string,\n\t\tTarget as string\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\trecreate:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> DriftedDebugSink\nSIteLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> SiteLookupCache\nMetricLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['MetricLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tfkMetric = pkiMetric,\n\t\tMetricLU\n\t)) ~> MetricLookupCache\nLocLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LocationLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tfkLocation = pkiLocation,\n\t\tLocationLookup\n\t)) ~> LocationCache\nTimeLineLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['TimeLine'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 0,\n\tmapColumn(\n\t\tfkTimeLine = pkiTimeLine,\n\t\tTimeLine\n\t)) ~> TimeLineCache\nPackLineKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LineKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkPackLine = pkiPackLine,\n\t\tLineKey\n\t)) ~> PackLineCache\nBrewhouseKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['BrewhouseKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkBrewhouse = pkiBrewhouse,\n\t\tBrewhouseKey\n\t)) ~> BrewhouseCache"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL2_copy3')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Fact DF"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_SDLevers",
								"type": "DatasetReference"
							},
							"name": "StagingTable"
						},
						{
							"dataset": {
								"referenceName": "SourceIDLookup",
								"type": "DatasetReference"
							},
							"name": "SourceIDs"
						},
						{
							"dataset": {
								"referenceName": "REF_FactLookup",
								"type": "DatasetReference"
							},
							"name": "FactLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_MetricLookup",
								"type": "DatasetReference"
							},
							"name": "MetricLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SIteLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_LocationLookup",
								"type": "DatasetReference"
							},
							"name": "LocationLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_TimeLineLookup",
								"type": "DatasetReference"
							},
							"name": "TimeLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_PackLineLookup",
								"type": "DatasetReference"
							},
							"name": "PackLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_BrewhouseLookup",
								"type": "DatasetReference"
							},
							"name": "BrewhouseLookup"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIRead",
								"type": "DatasetReference"
							},
							"name": "FactCopy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact2",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact1",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactD"
						},
						{
							"name": "SiteLookupCache"
						},
						{
							"name": "MetricLookupCache"
						},
						{
							"name": "LocationCache"
						},
						{
							"name": "TimeLineCache"
						},
						{
							"name": "PackLineCache"
						},
						{
							"name": "BrewhouseCache"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactWM"
						}
					],
					"transformations": [
						{
							"name": "UpdateRecords",
							"description": "Input rows that match on SourceLine"
						},
						{
							"name": "ExistingHash",
							"description": "Hash of characterising fields to match WTD and MTD elements"
						},
						{
							"name": "MarkUpdate1",
							"description": "Update the value and lastupdated date"
						},
						{
							"name": "InputHash",
							"description": "Hash of elements to identify similar records"
						},
						{
							"name": "NewRecords",
							"description": "Input rows that do not match on SourceLine\nNOTE Exists does not join the subquery"
						},
						{
							"name": "SplitTimeLines",
							"description": "Split MTD and WTD records from DAY records"
						},
						{
							"name": "MarkUpdate2",
							"description": "Update the value, sourceline and lastupdated date"
						},
						{
							"name": "Lookup1"
						},
						{
							"name": "Select1",
							"description": "pki and new value and lastupdated"
						},
						{
							"name": "Select2",
							"description": "PKI, and new sourceline, lastupdated and value"
						},
						{
							"name": "KeyFromSourceline",
							"description": "Look up the fact pki from the source line for matching source lines"
						},
						{
							"name": "LookupCurrent",
							"description": "Lookup primary key for matched record from sourceline"
						},
						{
							"name": "LookupKeys"
						},
						{
							"name": "LocLookup"
						},
						{
							"name": "PackLineKey"
						},
						{
							"name": "BrewhouseKey"
						},
						{
							"name": "MarkInsert"
						},
						{
							"name": "ConditionalSplit1"
						},
						{
							"name": "Select3"
						},
						{
							"name": "LookupKeys2"
						},
						{
							"name": "MarkInsert1"
						},
						{
							"name": "Select4"
						},
						{
							"name": "Select5"
						},
						{
							"name": "Select6"
						}
					],
					"script": "source(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingTable\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SourceIDs\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tMetricName as string,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactLookup\nsource(output(\n\t\tpkiMetric as long,\n\t\tMetricLU as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MetricLookup\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SIteLookup\nsource(output(\n\t\tpkiLocation as long,\n\t\tDivision as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LocationLookup\nsource(output(\n\t\tpkiTimeLine as integer,\n\t\tTimeLine as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TimeLineLookup\nsource(output(\n\t\tpkiPackLine as long,\n\t\tfkSite as long,\n\t\tLineName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PackLineLookup\nsource(output(\n\t\tpkiBrewhouse as long,\n\t\tfkSite as long,\n\t\tBrewhouseName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> BrewhouseLookup\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactCopy\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:false,\n\tbroadcast: 'auto')~> UpdateRecords\nFactLookup derive(hashExisting = md5(toString(fkDate), BrewName, TimeLine, Line, Brewhouse, MetricName)) ~> ExistingHash\nSelect6 alterRow(updateIf(true())) ~> MarkUpdate1\nStagingTable derive(TMTimeLine = (trim(TimeLine) == 'MTD') || (trim(TimeLine) == 'YTD'),\n\t\tInputHash = md5(toString(PeriodDate), BrewName, TimeLine, Line, Brewhouse, MetricName),\n\t\tLocLookup1 = lower(trim(Area) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, ''))),\n\t\tLineLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Line,\n\t\tBrewhouseLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Brewhouse,\n\t\tfkDate = PeriodDate) ~> InputHash\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewRecords\nNewRecords split((trim(TimeLine) == \"MTD\") || (trim(TimeLine) == \"WTD\"),\n\tdisjoint: false) ~> SplitTimeLines@(MTDWTDTimeLines, DAYTimeLine)\nConditionalSplit1@FuzzyMatched alterRow(updateIf(true())) ~> MarkUpdate2\nSplitTimeLines@MTDWTDTimeLines, ExistingHash lookup(InputHash == hashExisting,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nMarkUpdate1 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nMarkUpdate2 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nFactLookup select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate,\n\t\tBrewName,\n\t\tTimeLine,\n\t\tSubdivision,\n\t\tLine,\n\t\tBrewhouse,\n\t\tLocationLookup,\n\t\tMetricName,\n\t\tSourceLine,\n\t\tLastUpdated\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> KeyFromSourceline\nUpdateRecords, FactCopy lookup(StagingTable@SourceLine == FactCopy@SourceLine,\n\tmultiple: true,\n\tbroadcast: 'auto',\n\tpickup: 'any')~> LookupCurrent\nSplitTimeLines@DAYTimeLine derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong(0),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys\nLocationLookup derive(LocLookup = lower(trim(Subdivision) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, '')))) ~> LocLookup\nPackLineLookup derive(LineKey = toString(fkSite) + '|' + LineName) ~> PackLineKey\nBrewhouseLookup derive(BrewhouseKey = toString(fkSite) + '|' + BrewhouseName) ~> BrewhouseKey\nLookupKeys alterRow(insertIf(true())) ~> MarkInsert\nSelect3 split(InputHash == hashExisting,\n\tdisjoint: false) ~> ConditionalSplit1@(FuzzyMatched, FuzzyUnmatched)\nLookup1 select(mapColumn(\n\t\tBrewName = SplitTimeLines@MTDWTDTimeLines@BrewName,\n\t\tDateStarting,\n\t\tTimeLine = SplitTimeLines@MTDWTDTimeLines@TimeLine,\n\t\tFlowMeasure,\n\t\tSection,\n\t\tArea,\n\t\tValue,\n\t\tLine = SplitTimeLines@MTDWTDTimeLines@Line,\n\t\tBrewhouse = SplitTimeLines@MTDWTDTimeLines@Brewhouse,\n\t\tMetricName = SplitTimeLines@MTDWTDTimeLines@MetricName,\n\t\tPeriodDate,\n\t\tLastUpdated = SplitTimeLines@MTDWTDTimeLines@LastUpdated,\n\t\tfkBatchID,\n\t\tSourceLine = SplitTimeLines@MTDWTDTimeLines@SourceLine,\n\t\tInputHash,\n\t\tpkiFactKPI,\n\t\tfkDate = SplitTimeLines@MTDWTDTimeLines@fkDate,\n\t\thashExisting,\n\t\tLocLookup1,\n\t\tLineLookup,\n\t\tBrewhouseLookup\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select3\nConditionalSplit1@FuzzyUnmatched derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong(0),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys2\nLookupKeys2 alterRow(insertIf(true())) ~> MarkInsert1\nMarkInsert1 select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select4\nMarkInsert select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select5\nLookupCurrent select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate = FactCopy@fkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue = StagingTable@Value,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine = FactCopy@SourceLine,\n\t\tfkBatch = fkBatchID,\n\t\tLastUpdated = StagingTable@LastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select6\nSelect1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 2,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t)) ~> UpdateFact2\nSelect2 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 3,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tValue,\n\t\tSourceLine,\n\t\tLastUpdated\n\t)) ~> UpdateFact1\nSelect5 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 4,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactD\nSIteLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> SiteLookupCache\nMetricLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['MetricLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: (1),\n\tmapColumn(\n\t\tfkMetric = pkiMetric,\n\t\tMetricLU\n\t)) ~> MetricLookupCache\nLocLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LocationLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: (1),\n\tmapColumn(\n\t\tfkLocation = pkiLocation,\n\t\tLocationLookup\n\t)) ~> LocationCache\nTimeLineLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['TimeLine'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkTimeLine = pkiTimeLine,\n\t\tTimeLine\n\t)) ~> TimeLineCache\nPackLineKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LineKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkPackLine = pkiPackLine,\n\t\tLineKey\n\t)) ~> PackLineCache\nBrewhouseKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['BrewhouseKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkBrewhouse = pkiBrewhouse,\n\t\tBrewhouseKey\n\t)) ~> BrewhouseCache\nSelect4 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 5,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactWM"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFFactKPI_ETL2_copy4')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Fact DF"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_SDLevers",
								"type": "DatasetReference"
							},
							"name": "StagingTable"
						},
						{
							"dataset": {
								"referenceName": "SourceIDLookup",
								"type": "DatasetReference"
							},
							"name": "SourceIDs"
						},
						{
							"dataset": {
								"referenceName": "REF_FactLookup",
								"type": "DatasetReference"
							},
							"name": "FactLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_MetricLookup",
								"type": "DatasetReference"
							},
							"name": "MetricLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SIteLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_LocationLookup",
								"type": "DatasetReference"
							},
							"name": "LocationLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_TimeLineLookup",
								"type": "DatasetReference"
							},
							"name": "TimeLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_PackLineLookup",
								"type": "DatasetReference"
							},
							"name": "PackLineLookup"
						},
						{
							"dataset": {
								"referenceName": "REF_BrewhouseLookup",
								"type": "DatasetReference"
							},
							"name": "BrewhouseLookup"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIRead",
								"type": "DatasetReference"
							},
							"name": "FactCopy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact2",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPI",
								"type": "DatasetReference"
							},
							"name": "UpdateFact1",
							"description": "Update DWFactKPI"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactD"
						},
						{
							"name": "SiteLookupCache"
						},
						{
							"name": "MetricLookupCache"
						},
						{
							"name": "LocationCache"
						},
						{
							"name": "TimeLineCache"
						},
						{
							"name": "PackLineCache"
						},
						{
							"name": "BrewhouseCache"
						},
						{
							"dataset": {
								"referenceName": "DWFactKPIStaging",
								"type": "DatasetReference"
							},
							"name": "InsertFactWM"
						}
					],
					"transformations": [
						{
							"name": "UpdateRecords",
							"description": "Input rows that match on SourceLine"
						},
						{
							"name": "ExistingHash",
							"description": "Hash of characterising fields to match WTD and MTD elements"
						},
						{
							"name": "MarkUpdate1",
							"description": "Update the value and lastupdated date"
						},
						{
							"name": "InputHash",
							"description": "Hash of elements to identify similar records"
						},
						{
							"name": "NewRecords",
							"description": "Input rows that do not match on SourceLine\nNOTE Exists does not join the subquery"
						},
						{
							"name": "SplitTimeLines",
							"description": "Split MTD and WTD records from DAY records"
						},
						{
							"name": "MarkUpdate2",
							"description": "Update the value, sourceline and lastupdated date"
						},
						{
							"name": "Lookup1"
						},
						{
							"name": "Select1",
							"description": "pki and new value and lastupdated"
						},
						{
							"name": "Select2",
							"description": "PKI, and new sourceline, lastupdated and value"
						},
						{
							"name": "KeyFromSourceline",
							"description": "Look up the fact pki from the source line for matching source lines"
						},
						{
							"name": "LookupCurrent",
							"description": "Lookup primary key for matched record from sourceline"
						},
						{
							"name": "LookupKeys"
						},
						{
							"name": "LocLookup"
						},
						{
							"name": "PackLineKey"
						},
						{
							"name": "BrewhouseKey"
						},
						{
							"name": "MarkInsert"
						},
						{
							"name": "ConditionalSplit1"
						},
						{
							"name": "Select3"
						},
						{
							"name": "LookupKeys2"
						},
						{
							"name": "MarkInsert1"
						},
						{
							"name": "Select4"
						},
						{
							"name": "Select5"
						},
						{
							"name": "Select6"
						}
					],
					"script": "source(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingTable\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SourceIDs\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tMetricName as string,\n\t\tSourceLine as long,\n\t\tLastUpdated as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactLookup\nsource(output(\n\t\tpkiMetric as long,\n\t\tMetricLU as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MetricLookup\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SIteLookup\nsource(output(\n\t\tpkiLocation as long,\n\t\tDivision as string,\n\t\tSubdivision as string,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tLocationLookup as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LocationLookup\nsource(output(\n\t\tpkiTimeLine as integer,\n\t\tTimeLine as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TimeLineLookup\nsource(output(\n\t\tpkiPackLine as long,\n\t\tfkSite as long,\n\t\tLineName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PackLineLookup\nsource(output(\n\t\tpkiBrewhouse as long,\n\t\tfkSite as long,\n\t\tBrewhouseName as string,\n\t\tCheckCount as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> BrewhouseLookup\nsource(output(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> FactCopy\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:false,\n\tbroadcast: 'auto')~> UpdateRecords\nFactLookup derive(hashExisting = md5(toString(fkDate), BrewName, TimeLine, Line, Brewhouse, MetricName)) ~> ExistingHash\nSelect6 alterRow(updateIf(true())) ~> MarkUpdate1\nStagingTable derive(TMTimeLine = (trim(TimeLine) == 'MTD') || (trim(TimeLine) == 'YTD'),\n\t\tInputHash = md5(toString(PeriodDate), BrewName, TimeLine, Line, Brewhouse, MetricName),\n\t\tLocLookup1 = lower(trim(Area) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, ''))),\n\t\tLineLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Line,\n\t\tBrewhouseLookup = toString(SiteLookupCache#lookup(BrewName).fkSite) + '|' + Brewhouse,\n\t\tfkDate = PeriodDate) ~> InputHash\nInputHash, SourceIDs exists(StagingTable@SourceLine == SourceIDs@SourceLine,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewRecords\nNewRecords split((trim(TimeLine) == \"MTD\") || (trim(TimeLine) == \"WTD\"),\n\tdisjoint: false) ~> SplitTimeLines@(MTDWTDTimeLines, DAYTimeLine)\nConditionalSplit1@FuzzyMatched alterRow(updateIf(true())) ~> MarkUpdate2\nSplitTimeLines@MTDWTDTimeLines, ExistingHash lookup(InputHash == hashExisting,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nMarkUpdate1 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nMarkUpdate2 select(mapColumn(\n\t\tpkiFactKPI,\n\t\tSourceLine,\n\t\tLastUpdated,\n\t\tValue\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nFactLookup select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate,\n\t\tBrewName,\n\t\tTimeLine,\n\t\tSubdivision,\n\t\tLine,\n\t\tBrewhouse,\n\t\tLocationLookup,\n\t\tMetricName,\n\t\tSourceLine,\n\t\tLastUpdated\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> KeyFromSourceline\nUpdateRecords, FactCopy lookup(StagingTable@SourceLine == FactCopy@SourceLine,\n\tmultiple: true,\n\tbroadcast: 'auto',\n\tpickup: 'any')~> LookupCurrent\nSplitTimeLines@DAYTimeLine derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong(0),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys\nLocationLookup derive(LocLookup = lower(trim(Subdivision) + trim(coalesce(Line, '')) + trim(coalesce(Brewhouse, '')))) ~> LocLookup\nPackLineLookup derive(LineKey = toString(fkSite) + '|' + LineName) ~> PackLineKey\nBrewhouseLookup derive(BrewhouseKey = toString(fkSite) + '|' + BrewhouseName) ~> BrewhouseKey\nLookupKeys alterRow(insertIf(true())) ~> MarkInsert\nSelect3 split(InputHash == hashExisting,\n\tdisjoint: false) ~> ConditionalSplit1@(FuzzyMatched, FuzzyUnmatched)\nLookup1 select(mapColumn(\n\t\tBrewName = SplitTimeLines@MTDWTDTimeLines@BrewName,\n\t\tDateStarting,\n\t\tTimeLine = SplitTimeLines@MTDWTDTimeLines@TimeLine,\n\t\tFlowMeasure,\n\t\tSection,\n\t\tArea,\n\t\tValue,\n\t\tLine = SplitTimeLines@MTDWTDTimeLines@Line,\n\t\tBrewhouse = SplitTimeLines@MTDWTDTimeLines@Brewhouse,\n\t\tMetricName = SplitTimeLines@MTDWTDTimeLines@MetricName,\n\t\tPeriodDate,\n\t\tLastUpdated = SplitTimeLines@MTDWTDTimeLines@LastUpdated,\n\t\tfkBatchID,\n\t\tSourceLine = SplitTimeLines@MTDWTDTimeLines@SourceLine,\n\t\tInputHash,\n\t\tpkiFactKPI,\n\t\tfkDate = SplitTimeLines@MTDWTDTimeLines@fkDate,\n\t\thashExisting,\n\t\tLocLookup1,\n\t\tLineLookup,\n\t\tBrewhouseLookup\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select3\nConditionalSplit1@FuzzyUnmatched derive(fkSite = SiteLookupCache#lookup(BrewName).fkSite,\n\t\tfkMetric = MetricLookupCache#lookup(MetricName).fkMetric,\n\t\tfkLocation = LocationCache#lookup(LocLookup1).fkLocation,\n\t\tfkTimeLine = TimeLineCache#lookup(TimeLine).fkTimeLine,\n\t\tfkPackLine = PackLineCache#lookup(LineLookup).fkPackLine,\n\t\tfkBrewhouse = BrewhouseCache#lookup(BrewhouseLookup).fkBrewhouse,\n\t\tfkDomain = 1,\n\t\tfkBatchL = toLong(0),\n\t\tWeightingFactor = toDouble(0),\n\t\tTarget = toDouble(0),\n\t\tTargetWeightingFactor = toDouble(0),\n\t\tDisable = false()) ~> LookupKeys2\nLookupKeys2 alterRow(insertIf(true())) ~> MarkInsert1\nMarkInsert1 select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select4\nMarkInsert select(mapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch = fkBatchL,\n\t\tLastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select5\nLookupCurrent select(mapColumn(\n\t\tpkiFactKPI,\n\t\tfkDate = FactCopy@fkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue = StagingTable@Value,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine = FactCopy@SourceLine,\n\t\tfkBatch = fkBatchID,\n\t\tLastUpdated = StagingTable@LastUpdated,\n\t\tDisable\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select6\nSelect1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 2,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tLastUpdated,\n\t\tValue\n\t)) ~> UpdateFact2\nSelect2 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiFactKPI as long,\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['pkiFactKPI'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tsaveOrder: 3,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tpkiFactKPI,\n\t\tValue,\n\t\tSourceLine,\n\t\tLastUpdated\n\t)) ~> UpdateFact1\nSelect5 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 4,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactD\nSIteLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> SiteLookupCache\nMetricLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['MetricLU'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: (1),\n\tmapColumn(\n\t\tfkMetric = pkiMetric,\n\t\tMetricLU\n\t)) ~> MetricLookupCache\nLocLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LocationLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: (1),\n\tmapColumn(\n\t\tfkLocation = pkiLocation,\n\t\tLocationLookup\n\t)) ~> LocationCache\nTimeLineLookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['TimeLine'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkTimeLine = pkiTimeLine,\n\t\tTimeLine\n\t)) ~> TimeLineCache\nPackLineKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['LineKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkPackLine = pkiPackLine,\n\t\tLineKey\n\t)) ~> PackLineCache\nBrewhouseKey sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tkeys:['BrewhouseKey'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tfkBrewhouse = pkiBrewhouse,\n\t\tBrewhouseKey\n\t)) ~> BrewhouseCache\nSelect4 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tfkDate as date,\n\t\tfkSite as long,\n\t\tfkLocation as long,\n\t\tfkPackLine as long,\n\t\tfkBrewhouse as long,\n\t\tfkMetric as long,\n\t\tfkDomain as integer,\n\t\tfkTimeLine as integer,\n\t\tValue as double,\n\t\tWeightingFactor as double,\n\t\tTarget as double,\n\t\tTargetWeightingFactor as double,\n\t\tSourceLine as long,\n\t\tfkBatch as long,\n\t\tLastUpdated as timestamp,\n\t\tDisable as boolean\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tsaveOrder: 5,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tfkDate,\n\t\tfkSite,\n\t\tfkLocation,\n\t\tfkPackLine,\n\t\tfkBrewhouse,\n\t\tfkMetric,\n\t\tfkDomain,\n\t\tfkTimeLine,\n\t\tValue,\n\t\tWeightingFactor,\n\t\tTarget,\n\t\tTargetWeightingFactor,\n\t\tSourceLine,\n\t\tfkBatch,\n\t\tLastUpdated,\n\t\tDisable\n\t)) ~> InsertFactWM"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/PowerQuery1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "WranglingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"name": "dboTestTable1",
							"script": "source(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> dboTestTable1",
							"dataset": {
								"referenceName": "dboTestTable1",
								"type": "DatasetReference"
							}
						}
					],
					"script": "section Section1;\r\nshared dboTestTable1 = let\r\n  AdfDoc = Sql.Database(\"supplydatastoreserver.database.windows.net\", \"SupplyDataStore\"),\r\n  InputTable = AdfDoc{[Schema = \"dbo\", Item = \"TestTable1\"]}[Data]\r\nin\r\n  InputTable;\r\nshared UserQuery = let\r\n  Source = dboTestTable1\r\nin\r\n  Source;\r\n"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TargetsETL2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_TargetStaging",
								"type": "DatasetReference"
							},
							"name": "ODSTargets"
						},
						{
							"dataset": {
								"referenceName": "REF_TargetMapping",
								"type": "DatasetReference"
							},
							"name": "REFTargetMapping"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "REFSite"
						},
						{
							"dataset": {
								"referenceName": "REF_Month",
								"type": "DatasetReference"
							},
							"name": "REFMonth"
						},
						{
							"dataset": {
								"referenceName": "REF_Year",
								"type": "DatasetReference"
							},
							"name": "REFYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DW_Targets",
								"type": "DatasetReference"
							},
							"name": "DWTargets"
						}
					],
					"transformations": [
						{
							"name": "TargetValue",
							"description": "Convert target to float"
						},
						{
							"name": "LookupMeasure",
							"description": "Lookup fkMeasure from REFTargetMapping"
						},
						{
							"name": "SplitMTDYTD",
							"description": "Split the stream into MTD and YTD groups to assign the Target to the correct field"
						},
						{
							"name": "MTDCalc",
							"description": "Assign the target (TargetF) to ValueMTD"
						},
						{
							"name": "YTDCalc",
							"description": "Assign the target (TargetF) to ValueYTD"
						},
						{
							"name": "Combine"
						},
						{
							"name": "Select1",
							"description": "Limit to active fields"
						},
						{
							"name": "LookupMonth"
						},
						{
							"name": "LookupYear"
						},
						{
							"name": "OtherFields",
							"description": "Creating the columns fkTimeLine, LastUpdated, fkDate"
						},
						{
							"name": "LookupSite"
						},
						{
							"name": "Select2"
						},
						{
							"name": "Select3"
						}
					],
					"script": "source(output(\n\t\tpkiTargetStaging as long,\n\t\tConcatenate as string,\n\t\t{BU Region} as string,\n\t\t{BU Region 2} as string,\n\t\tBURegion as string,\n\t\tCountry as string,\n\t\tPlant as string,\n\t\t{Plt Code} as string,\n\t\t{Fin Year} as string,\n\t\tMonth as string,\n\t\t{MTD/YTD} as string,\n\t\tVersion as string,\n\t\t{KPI Name} as string,\n\t\tTarget as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ODSTargets\nsource(output(\n\t\tpkiTargetMapping as long,\n\t\tTargetSourceName as string,\n\t\tMeasureName as string,\n\t\tfkMeasure as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFTargetMapping\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFSite\nsource(output(\n\t\tName as string,\n\t\tMonthN as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFMonth\nsource(output(\n\t\tFYear as string,\n\t\tNYear as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFYear\nSelect1 derive(TargetF = toFloat(Target),\n\t\tMeasureLookup = trim({KPI Name})) ~> TargetValue\nTargetValue, REFTargetMapping lookup(MeasureLookup == TargetSourceName,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupMeasure\nLookupMeasure split({MTD/YTD} == 'MTD',\n\t{MTD/YTD} == 'YTD',\n\tdisjoint: true) ~> SplitMTDYTD@(MTD, YTD)\nSplitMTDYTD@MTD derive(ValueMTD = TargetF,\n\t\tSiteLookup = lower(Plant)) ~> MTDCalc\nSplitMTDYTD@YTD derive(ValueYTD = TargetF) ~> YTDCalc\nMTDCalc, YTDCalc join(SplitMTDYTD@MTD@Plant == SplitMTDYTD@YTD@Plant\n\t&& SplitMTDYTD@MTD@{Fin Year} == SplitMTDYTD@YTD@{Fin Year}\n\t&& SplitMTDYTD@MTD@Month == SplitMTDYTD@YTD@Month\n\t&& SplitMTDYTD@MTD@{KPI Name} == SplitMTDYTD@YTD@{KPI Name}\n\t&& SplitMTDYTD@MTD@fkMeasure == SplitMTDYTD@YTD@fkMeasure,\n\tjoinType:'inner',\n\tbroadcast: 'left')~> Combine\nODSTargets select(mapColumn(\n\t\tPlant,\n\t\t{Fin Year},\n\t\tMonth,\n\t\t{MTD/YTD},\n\t\t{KPI Name},\n\t\tTarget\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nLookupSite, REFMonth lookup(Month == Name,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupMonth\nLookupMonth, REFYear lookup({Fin Year} == FYear,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupYear\nSelect3 derive(fkTimeline = 3,\n\t\tLastUpdated = currentTimestamp(),\n\t\tfkDate = toDate(addDays(addMonths(toTimestamp(toString(NYear) + '.01.01', 'yyyy.MM.dd'), MonthN), -1))) ~> OtherFields\nSelect2, REFSite lookup(Select2@SiteLookup == REFSite@SiteLookup,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupSite\nCombine select(mapColumn(\n\t\tPlant = SplitMTDYTD@MTD@Plant,\n\t\t{Fin Year} = SplitMTDYTD@MTD@{Fin Year},\n\t\tMonth = SplitMTDYTD@MTD@Month,\n\t\t{KPI Name} = SplitMTDYTD@MTD@{KPI Name},\n\t\tfkMeasure = SplitMTDYTD@MTD@fkMeasure,\n\t\tValueMTD,\n\t\tValueYTD,\n\t\tSiteLookup\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nLookupYear select(mapColumn(\n\t\tfkMeasure,\n\t\tValueMTD,\n\t\tValueYTD,\n\t\tfkSite,\n\t\tMonthN,\n\t\tNYear\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select3\nOtherFields sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiTargets as long,\n\t\tfkMeasure as long,\n\t\tfkSite as long,\n\t\tfkDate as date,\n\t\tfkTimeLine as integer,\n\t\tValueMTD as double,\n\t\tValueYTD as double,\n\t\tLastUpdated as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\ttruncate:true,\n\tformat: 'table',\n\tdateFormat:'yyyy-MM-dd',\n\ttimestampFormat:'yyyy.MM.dd HH:mm:ss',\n\terrorHandlingOption: 'allErrors',\n\ttransactionCommit: 'single',\n\treportSuccessOnError: false,\n\tmapColumn(\n\t\tValueMTD,\n\t\tValueYTD,\n\t\tfkMeasure,\n\t\tfkTimeLine = fkTimeline,\n\t\tfkDate,\n\t\tLastUpdated,\n\t\tfkSite\n\t)) ~> DWTargets"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TargetsETL2V2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "dboTestTable1",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dboTestTable2",
								"type": "DatasetReference"
							},
							"name": "sinka"
						}
					],
					"transformations": [],
					"script": "source(output(\n\t\tpki as long,\n\t\tFinYear as string,\n\t\tMonth as string,\n\t\tfkDate as date,\n\t\tfkDateTime as timestamp,\n\t\tSite as string,\n\t\tfkSite as long,\n\t\tfkTimeLine as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> source1\nsource1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpki as long,\n\t\tFinYear as string,\n\t\tMonth as string,\n\t\tfkDate as date,\n\t\tfkDateTime as timestamp,\n\t\tSite as string,\n\t\tfkSite as long,\n\t\tfkTimeLine as integer\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> sinka"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TargetsETL2_Clone')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ODS_TargetStaging",
								"type": "DatasetReference"
							},
							"name": "ODSTargets"
						},
						{
							"dataset": {
								"referenceName": "REF_TargetMapping",
								"type": "DatasetReference"
							},
							"name": "REFTargetMapping"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "REFSite"
						},
						{
							"dataset": {
								"referenceName": "REF_Month",
								"type": "DatasetReference"
							},
							"name": "REFMonth"
						},
						{
							"dataset": {
								"referenceName": "REF_Year",
								"type": "DatasetReference"
							},
							"name": "REFYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DW_Targets",
								"type": "DatasetReference"
							},
							"name": "DWTargets"
						},
						{
							"dataset": {
								"referenceName": "DebugOutput",
								"type": "DatasetReference"
							},
							"name": "DebugSink"
						}
					],
					"transformations": [
						{
							"name": "TargetValue",
							"description": "Convert target to float"
						},
						{
							"name": "LookupMeasure",
							"description": "Lookup fkMeasure from REFTargetMapping"
						},
						{
							"name": "SplitMTDYTD",
							"description": "This leg gets YTD target values."
						},
						{
							"name": "MTDCalc"
						},
						{
							"name": "YTDCalc"
						},
						{
							"name": "Combine"
						},
						{
							"name": "Select1",
							"description": "Limit to active fields"
						},
						{
							"name": "LookupMonth"
						},
						{
							"name": "LookupYear"
						},
						{
							"name": "OtherFields",
							"description": "Creating the columns fkTimeLine, LastUpdated, fkDate"
						},
						{
							"name": "LookupSite"
						},
						{
							"name": "Select2"
						},
						{
							"name": "Select3"
						},
						{
							"name": "SelectDebug"
						}
					],
					"script": "source(output(\n\t\tpkiTargetStaging as long,\n\t\tConcatenate as string,\n\t\t{BU Region} as string,\n\t\t{BU Region 2} as string,\n\t\tBURegion as string,\n\t\tCountry as string,\n\t\tPlant as string,\n\t\t{Plt Code} as string,\n\t\t{Fin Year} as string,\n\t\tMonth as string,\n\t\t{MTD/YTD} as string,\n\t\tVersion as string,\n\t\t{KPI Name} as string,\n\t\tTarget as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ODSTargets\nsource(output(\n\t\tpkiTargetMapping as long,\n\t\tTargetSourceName as string,\n\t\tMeasureName as string,\n\t\tfkMeasure as long\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFTargetMapping\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFSite\nsource(output(\n\t\tName as string,\n\t\tMonthN as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFMonth\nsource(output(\n\t\tFYear as string,\n\t\tNYear as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> REFYear\nSelect1 derive(TargetF = toFloat(Target)) ~> TargetValue\nTargetValue, REFTargetMapping lookup({KPI Name} == TargetSourceName,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupMeasure\nLookupMeasure split({MTD/YTD} == 'MTD',\n\t{MTD/YTD} == 'YTD',\n\tdisjoint: true) ~> SplitMTDYTD@(MTD, YTD)\nSplitMTDYTD@MTD derive(ValueMTD = TargetF) ~> MTDCalc\nSplitMTDYTD@YTD derive(ValueYTD = TargetF) ~> YTDCalc\nMTDCalc, YTDCalc join(SplitMTDYTD@MTD@Plant == SplitMTDYTD@YTD@Plant\n\t&& SplitMTDYTD@MTD@{Fin Year} == SplitMTDYTD@YTD@{Fin Year}\n\t&& SplitMTDYTD@MTD@Month == SplitMTDYTD@YTD@Month\n\t&& SplitMTDYTD@MTD@{KPI Name} == SplitMTDYTD@YTD@{KPI Name}\n\t&& SplitMTDYTD@MTD@fkMeasure == SplitMTDYTD@YTD@fkMeasure,\n\tjoinType:'inner',\n\tbroadcast: 'left')~> Combine\nODSTargets select(mapColumn(\n\t\tPlant,\n\t\t{Fin Year},\n\t\tMonth,\n\t\t{MTD/YTD},\n\t\t{KPI Name},\n\t\tTarget\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nLookupSite, REFMonth lookup(Month == Name,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupMonth\nLookupMonth, REFYear lookup({Fin Year} == FYear,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupYear\nSelect3 derive(fkTimeline = 3,\n\t\tLastUpdated = currentTimestamp(),\n\t\tfkDate = toDate(addDays(addMonths(toTimestamp(toString(NYear) + '.01.01', 'yyyy.MM.dd'), MonthN), -1))) ~> OtherFields\nSelect2, REFSite lookup(Plant == SiteLookup,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupSite\nCombine select(mapColumn(\n\t\tPlant = SplitMTDYTD@MTD@Plant,\n\t\t{Fin Year} = SplitMTDYTD@MTD@{Fin Year},\n\t\tMonth = SplitMTDYTD@MTD@Month,\n\t\t{KPI Name} = SplitMTDYTD@MTD@{KPI Name},\n\t\tfkMeasure = SplitMTDYTD@MTD@fkMeasure,\n\t\tValueMTD,\n\t\tValueYTD\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select2\nLookupYear select(mapColumn(\n\t\tfkMeasure,\n\t\tValueMTD,\n\t\tValueYTD,\n\t\tfkSite,\n\t\tMonthN,\n\t\tNYear\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select3\nSplitMTDYTD@YTD select(mapColumn(\n\t\tPlant,\n\t\t{Fin Year},\n\t\tMonth,\n\t\t{MTD/YTD},\n\t\t{KPI Name},\n\t\tTarget\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectDebug\nOtherFields sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpkiTargets as long,\n\t\tfkMeasure as long,\n\t\tfkSite as long,\n\t\tfkDate as date,\n\t\tfkTimeLine as integer,\n\t\tValueMTD as double,\n\t\tValueYTD as double,\n\t\tLastUpdated as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\ttruncate:true,\n\tformat: 'table',\n\tdateFormat:'yyyy-MM-dd',\n\ttimestampFormat:'yyyy.MM.dd HH:mm:ss',\n\terrorHandlingOption: 'allErrors',\n\ttransactionCommit: 'single',\n\treportSuccessOnError: false,\n\tmapColumn(\n\t\tValueMTD,\n\t\tValueYTD,\n\t\tfkMeasure,\n\t\tfkTimeLine = fkTimeline,\n\t\tfkDate,\n\t\tLastUpdated,\n\t\tfkSite\n\t)) ~> DWTargets\nSelectDebug sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tPlant as string,\n\t\t{Fin Year} as string,\n\t\tMonth as string,\n\t\t{MTD/YTD} as string,\n\t\t{KPI Name} as string,\n\t\tTarget as string\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\trecreate:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'allErrors',\n\ttransactionCommit: 'single',\n\treportSuccessOnError: true) ~> DebugSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Test Lookipups')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LookupSite",
								"type": "DatasetReference"
							},
							"name": "LookupSite"
						},
						{
							"dataset": {
								"referenceName": "LookupTestSourceDS",
								"type": "DatasetReference"
							},
							"name": "LookupTestSource"
						}
					],
					"sinks": [
						{
							"name": "LookupTestSiteSink"
						},
						{
							"dataset": {
								"referenceName": "LookupTestResSink",
								"type": "DatasetReference"
							},
							"name": "LookupTestResSink"
						}
					],
					"transformations": [
						{
							"name": "Select1"
						},
						{
							"name": "DerivedColumn1"
						},
						{
							"name": "Select2"
						}
					],
					"script": "source(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LookupSite\nsource(output(\n\t\tBrewName as string,\n\t\tDateStarting as date,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tSection as string,\n\t\tArea as string,\n\t\tValue as double,\n\t\tLine as string,\n\t\tBrewhouse as string,\n\t\tMetricName as string,\n\t\tPeriodDate as date,\n\t\tLastUpdated as timestamp,\n\t\tpkiSDLevers as long,\n\t\tfkBatchID as integer,\n\t\tSourceLine as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LookupTestSource\nLookupTestSource select(mapColumn(\n\t\tBrewName,\n\t\tTimeLine,\n\t\tFlowMeasure,\n\t\tSection,\n\t\tArea,\n\t\tLine,\n\t\tBrewhouse,\n\t\tMetricName,\n\t\tpkiSDLevers,\n\t\tSourceLine\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> Select1\nSelect1 derive(fkSite = LookupTestSiteSink#lookup(BrewName).fkSite) ~> DerivedColumn1\nLookupSite select(mapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: true) ~> Select2\nSelect2 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tkeys:['SiteLookup'],\n\tstore: 'cache',\n\tformat: 'inline',\n\toutput: false,\n\tsaveOrder: 1,\n\tmapColumn(\n\t\tSiteLookup,\n\t\tfkSite\n\t)) ~> LookupTestSiteSink\nDerivedColumn1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tBrewName as string,\n\t\tTimeLine as string,\n\t\tFlowMeasure as string,\n\t\tfkSite as long\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\ttruncate:true,\n\tformat: 'table',\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tBrewName,\n\t\tTimeLine,\n\t\tFlowMeasure,\n\t\tfkSite\n\t)) ~> LookupTestResSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TestDateCalcsFlow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "dboTestTable1",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "REF_Month",
								"type": "DatasetReference"
							},
							"name": "MonthLU"
						},
						{
							"dataset": {
								"referenceName": "REF_Year",
								"type": "DatasetReference"
							},
							"name": "YearLU"
						},
						{
							"dataset": {
								"referenceName": "REF_SiteLookup",
								"type": "DatasetReference"
							},
							"name": "SiteLU"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dboTestTable2",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "DerivedColumn1"
						},
						{
							"name": "Select1"
						},
						{
							"name": "LookupYear"
						},
						{
							"name": "LookupMonth"
						},
						{
							"name": "LookupSite"
						}
					],
					"script": "source(output(\n\t\tpki as long,\n\t\tFinYear as string,\n\t\tMonth as string,\n\t\tfkDate as date,\n\t\tfkDateTime as timestamp,\n\t\tSite as string,\n\t\tfkSite as long,\n\t\tfkTimeLine as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> source1\nsource(output(\n\t\tName as string,\n\t\tMonthN as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> MonthLU\nsource(output(\n\t\tFYear as string,\n\t\tNYear as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> YearLU\nsource(output(\n\t\tSiteName as string,\n\t\tSiteLookup as string,\n\t\tfkSite as long\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SiteLU\nLookupMonth derive(fkDate = toDate(addDays(addMonths(toTimestamp(toString(NYear) + '.01.01', 'yyyy.MM.dd'), MonthN), -1)),\n\t\tfkDateTime = addDays(addMonths(toTimestamp(toString(NYear) + '.01.01', 'yyyy.MM.dd'), MonthN), -1),\n\t\tfkTimeLine = 3) ~> DerivedColumn1\nsource1 select(mapColumn(\n\t\tFinYear,\n\t\tMonth,\n\t\tSite\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select1\nLookupSite, YearLU lookup(FinYear == FYear,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupYear\nLookupYear, MonthLU lookup(Month == Name,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupMonth\nSelect1, SiteLU lookup(Site == SiteLookup,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupSite\nDerivedColumn1 sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tpki as long,\n\t\tFinYear as string,\n\t\tMonth as string,\n\t\tfkDate as date,\n\t\tfkDateTime as timestamp,\n\t\tSite as string,\n\t\tfkSite as long,\n\t\tfkTimeLine as integer\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tdateFormat:'yyyy/MM/dd',\n\ttimestampFormat:'yyyy.MM.dd HH:mm:ss',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tFinYear,\n\t\tMonth,\n\t\tfkDate,\n\t\tfkDateTime,\n\t\tSite,\n\t\tfkSite,\n\t\tfkTimeLine\n\t)) ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Dynamic Backup Parent')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Lookup Tables",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": {
									"value": "SELECT TABLE_SCHEMA as schemas,\n\tTABLE_NAME as tables\nFROM INFORMATION_SCHEMA.TABLES\nWHERE TABLE_TYPE = 'BASE TABLE'\nAND TABLE_SCHEMA <> 'dbo'",
									"type": "Expression"
								},
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DynBackupControl",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "DynBackup_ForEach",
						"description": "Copy tables to data store",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Lookup Tables",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup Tables').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "MasterPipeline",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "Dynamic Backup Child",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"Schema": {
												"value": "@{item().schemas}",
												"type": "Expression"
											},
											"Table": {
												"value": "@{item().tables}",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Dynamic Backup"
				},
				"annotations": [],
				"lastPublishTime": "2021-06-02T10:03:36Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/FactKPI_ETL2')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "FactKPIStaging Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DFFactKPI_ETL2",
								"type": "DataFlowReference",
								"parameters": {
									"BatchNumber": "toLong(0)"
								},
								"datasetParameters": {
									"StagingTable": {},
									"SourceIDs": {},
									"FactLookup": {},
									"MetricLookup": {},
									"SIteLookup": {},
									"LocationLookup": {},
									"TimeLineLookup": {},
									"PackLineLookup": {},
									"BrewhouseLookup": {},
									"FactCopy": {},
									"UpdateFact2": {},
									"UpdateFact1": {},
									"InsertFactD": {},
									"SiteLookupCache": {},
									"MetricLookupCache": {},
									"LocationCache": {},
									"TimeLineCache": {},
									"PackLineCache": {},
									"BrewhouseCache": {},
									"InsertFactWM": {},
									"UpdateTracker1": {},
									"UpdateTracker2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "InsertFacts",
						"description": "Insert facts from the fact staging table",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "FactKPIStaging Flow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[DW].[spInsertFacts]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Complete"
				},
				"annotations": [],
				"lastPublishTime": "2021-06-02T10:03:40Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/DFFactKPI_ETL2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FactKPI_ETL2_copy1')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "GetBatchNumber",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DFFactKPI_ETL2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"StagingTable": {},
									"SourceIDs": {},
									"FactLookup": {},
									"MetricLookup": {},
									"SIteLookup": {},
									"LocationLookup": {},
									"TimeLineLookup": {},
									"PackLineLookup": {},
									"BrewhouseLookup": {},
									"FactCopy": {},
									"UpdateFact2": {},
									"UpdateFact1": {},
									"InsertFactD": {},
									"SiteLookupCache": {},
									"MetricLookupCache": {},
									"LocationCache": {},
									"TimeLineCache": {},
									"PackLineCache": {},
									"BrewhouseCache": {},
									"InsertFactWM": {},
									"UpdateTracker1": {},
									"UpdateTracker2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Create New Batch",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[AU].[spInsertBatch]",
							"storedProcedureParameters": {
								"Description": {
									"value": "SDLevers Fact Load",
									"type": "String"
								},
								"Rows": {
									"value": "0",
									"type": "Int64"
								},
								"Status": {
									"value": "Opened",
									"type": "String"
								},
								"Target": {
									"value": "DW.FactKPI",
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "GetBatchNumber",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Create New Batch",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT Max(pkiBatch) as MaxBatch FROM  AU.Batch",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "dboTestTable1",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Dev"
				},
				"annotations": [],
				"lastPublishTime": "2021-06-02T10:03:40Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/DFFactKPI_ETL2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FactKPI_ETL2_copy2')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "FactKPIStaging Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DFFactKPI_ETL2_TEST",
								"type": "DataFlowReference",
								"parameters": {
									"BatchNumber": "toLong(0)"
								},
								"datasetParameters": {
									"StagingTable": {},
									"SourceIDs": {},
									"FactLookup": {},
									"MetricLookup": {},
									"SIteLookup": {},
									"LocationLookup": {},
									"TimeLineLookup": {},
									"PackLineLookup": {},
									"BrewhouseLookup": {},
									"FactCopy": {},
									"UpdateFact2": {},
									"UpdateFact1": {},
									"InsertFactD": {},
									"SiteLookupCache": {},
									"MetricLookupCache": {},
									"LocationCache": {},
									"TimeLineCache": {},
									"PackLineCache": {},
									"BrewhouseCache": {},
									"InsertFactWM": {},
									"UpdateTracker1": {},
									"UpdateTracker2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "InsertFacts",
						"description": "Insert facts from the fact staging table",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "FactKPIStaging Flow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[DW].[spInsertFacts]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Complete"
				},
				"annotations": [],
				"lastPublishTime": "2021-06-02T10:03:41Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/DFFactKPI_ETL2_TEST')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FactKPI_ETL_copy1')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "ETL1 and 2 combined",
				"activities": [
					{
						"name": "Facts ETL2",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Facts ETL1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DFFactKPI_ETL2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"StagingTable": {},
									"SourceIDs": {},
									"FactLookup": {},
									"MetricLookup": {},
									"SIteLookup": {},
									"LocationLookup": {},
									"TimeLineLookup": {},
									"PackLineLookup": {},
									"BrewhouseLookup": {},
									"FactCopy": {},
									"UpdateFact2": {},
									"UpdateFact1": {},
									"InsertFactD": {},
									"SiteLookupCache": {},
									"MetricLookupCache": {},
									"LocationCache": {},
									"TimeLineCache": {},
									"PackLineCache": {},
									"BrewhouseCache": {},
									"InsertFactWM": {},
									"UpdateTracker1": {},
									"UpdateTracker2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Insert New Facts",
						"description": "Insert facts from the fact staging table",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Facts ETL2",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[DW].[spInsertFacts]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "Facts ETL1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DFFactKPI_ETL1",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"SDLeversOut2": {},
									"vwDateAdjustLookup2": {},
									"snkDateAdjust2": {},
									"StagingSink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Calc Derived Measures",
						"description": "Reset Measure Staging and calculated the derived measures",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Insert New Facts",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [
							{
								"name": "Test",
								"value": "123"
							}
						],
						"typeProperties": {
							"storedProcedureName": "[[CA].[spCalc_SD_HeadlineMeasures]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "Reset Measures",
						"description": "Delete measures from FactKPI",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Calc Derived Measures",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[CA].[spResetMeasures]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "Insert Measures and Weights",
						"description": "Insert contents of Measure Staging to FactKPI",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Reset Measures",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[CA].[spInsertMeasures]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "LogExtractDate",
						"description": "Store source date of latest as a basis for  the incremental load.",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Insert Measures and Weights",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[AU].[spSetODSDateTime]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"LoadBatchP": {
						"type": "string",
						"defaultValue": "'0'"
					}
				},
				"folder": {
					"name": "Complete"
				},
				"annotations": [],
				"lastPublishTime": "2021-06-02T10:03:40Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/DFFactKPI_ETL2')]",
				"[concat(variables('factoryId'), '/dataflows/DFFactKPI_ETL1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FactsETL1')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "FactsETL1",
						"description": "Pull data from Source to Staging table",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DFFactKPI_ETL1",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"SDLeversOut2": {},
									"vwDateAdjustLookup2": {},
									"snkDateAdjust2": {},
									"StagingSink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "LogExtractDate",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "FactsETL1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[AU].[spSetODSDateTime]"
						},
						"linkedServiceName": {
							"referenceName": "supplydatastore_server",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"LoadBatchP": {
						"type": "string",
						"defaultValue": "'1'"
					}
				},
				"folder": {
					"name": "Complete"
				},
				"annotations": [],
				"lastPublishTime": "2021-06-02T10:03:33Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/DFFactKPI_ETL1')]"
			]
		}
	]
}